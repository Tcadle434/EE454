
I have uploaded a sequence of image files that can be used as input for running your project 2 code on, along with a file that denotes the "ground truth" of how many people are in each image, the bounding box around each person, and the true identity label of each person (so all the boxes for a particular person will have the same label across all images).  A sample file called parseGroundTruth.m is included that shows how to read in the ground truth xml file.  It also includes some sample code to read each image in and display the bounding boxes and identity label of all people in that image.  
 
Our minimal project specification is to use two images and the associated bounding boxes, and match them up.  Choose whichever two images from the sequence you want.  Images closer together in time will be easier; farther apart in time will be more challenging.  Once it works for two images, you might want to try running on three or more images to do "tracking" by matching between adjacent pairs.
 
The file assignmentoptimal.c contains code for running the Hungarian algorithm to match items between two images based on the matrix of pairwise scores you will be computing.  You will need to compile this code the first time you use it by doing "mex assignmentoptimal.c" in Matlab.  I have tested that this works in the PSU WebApps version of matlab (Windows), and it works on my Mac too, so compiling this one file shouldn't present any problems.  Play with it a bit and read the comments to make sure you understand what the input and output behavior is, particularly for input matrices that are nonsquare -- e.g. if you were trying to match 4 items in one image with 5 in another, or vice versa, how does the vector of output assignments denote the unmatched items.  Also, one intellectual "hurdle" you will need to overcome is to figure out how to use code that assumes smaller scores are better for matching when you are computing affinity scores where bigger numbers are better (e.g. number of bidirectional corner matches between two bounding boxes).  The code requires all numbers to be nonnegative, so merely negating the counts won't work. Something along that line of thinking is the key, however.
 
Just in case nothing in this message sounds familiar, I have uploaded snapshots of what we wrote on the blackboard during the class period that was devoted to defining project 2.  Most all of the subpieces are things we have gone over in lectures during the semester, and in many cases pseudocode can be found in the relevant lecture notes (e.g. Harris corner detection; using RANSAC to estimate a translation).  You have a bit more leeway with this project to be creative about how you do each piece, just make sure to explain what you did and why you did it in the project report.